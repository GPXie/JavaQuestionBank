# 12.多线程

## 一、单选

- 题目说明：

​       题目难度：

​       题目考核知识点：多线程

​       答案：

​       题目解析：



- 题目说明：以下（   ）不属于线程的状态。

    A．就绪状态    B。运行状态   C。挂起状态   D。独占状态

​       题目难度：简单

​       题目考核知识点：多线程

​       答案：D

​       题目解析：



- 题目说明：当线程被创建后，其所处的状态是（   ）

     A．阻塞状态  B。运行状态   C、就绪状态  D、新建状态

​       题目难度：简单

​       题目考核知识点：多线程

​       答案：D

​       题目解析：



- 题目说明： 当线程调用start()后，其所处状态为（  ）

  ​    A．阻塞状态  B。运行状态   C、就绪状态  D、新建状态

​       题目难度：简单

​       题目考核知识点：多线程

​       答案：C

​       题目解析：



- 题目说明：Thread.sleep（）方法调用后，当等待时间未到，该线程所处状态为（   ）

       题目难度：简单

       题目考核知识点：多线程

       答案：A

       题目解析：



## 二、多选



## 三、填空

### 程序填空

- 题目说明：下列程序的功能是在监控台上每隔一秒钟显示一个字符串“Hello”,能够填写在程序中下划线位置，使程序完整并能正确运行的语句是   

  ```java
  public class Test implements Runnable{  
  public static void main(String args[]){  
  Test t=new Test();  
  Thread tt=new Thread(t);  
  tt.start();  
  }  
  public void run(){  
  for(;;){  
  try{ 
        _______________  ;  
  }catch(______________________  e){}  
  System.put.println("Hello");  
  }  
  }  
  }  
  
  ```

  

​       题目难度：

​       题目考核知识点：多线程

​       答案： Thread.sleep(1000) 

​                    InterruptedException

​       题目解析：



### 读程序写结果







## 四、简答

### 基本概念解释

- 题目说明：线程和进程有什么区别？

​       题目难度：简单

​       题目考核知识点：多线程

​       答案：线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同   的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。 

​       题目解析：



- 题目说明：线程的生命期内包括哪些状态？ 

​       题目难度：简单

​       题目考核知识点：多线程

​       答案：新建状态、就绪状态、运行状态、阻塞状态、死亡状态

​       题目解析：





- 题目说明：什么是线程安全？

​       题目难度：简单

​       题目考核知识点：多线程

​       答案：

线程安全：多线程访问时，采用了加锁机制，当一个数据访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。
线程不安全：不提供数据访问保护，有可能多个线程先后更改数据造成所得到的数据是脏数据。

​       题目解析：



- 题目说明：两个线程之间，如何实现数据共享？

​       题目难度：简单

​       题目考核知识点：多线程

​       答案：

①、使用同一个 Runnable 对象；
②、使用不同的 Runnable 对象：
i、将共享数据分别传递给两个不同的线程；
ii、将这些 Runnable 对象作为一个内部类，将共享数据作为成员变量

​       题目解析：



- 题目说明：sleep() 方法和 wait() 方法有什么区别？

​       题目难度：简单

​       题目考核知识点：多线程

​       答案：

①、所在的类：sleep 在 Thread 类中、wait 在 Object 类中；
②、锁：sleep 方法没有释放锁、wait 方法释放了锁；
③、使用范围：sleep 可以在任何地方使用、而 wait，notify 和 notifyAll 只能在同步控制方法或者同步控制块里面使用。

​       题目解析：



- 题目说明：什么是死锁？死锁发生的必要条件？如何避免死锁？

​       题目难度：简单

​       题目考核知识点：多线程

​       答案：

死锁：两个及以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，他们都将无法推进下去。

死锁的必要条件：
①、互斥条件：一个资源每次只能被一个进程使用；
②、请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不变；
③、不剥夺条件：进程已获得的资源，在未使用之前，不能强行剥夺；
④、循环等待条件：若干进程之间形成一种头尾相连的循环等待资源关系。

避免死锁最简单的方法：阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序做操作。

​       题目解析：



- 题目说明：启动一个线程是用 run() 还是 start()?

​       题目难度：简单

​       题目考核知识点：多线程

​       答案：

启动一个线程是调用 start() 方法, 使线程所代表的虚拟处理机处于可运行状态, 这意味着它可以由 JVM 调度并执行。这并不意味着线程就会立即运行。run() 方法可以产生必须退出的标志来停止一个线程。 

​       题目解析：

### 程序题改错







## 五、编程题

- ​题目说明： 写两个线程，一个线程打印 1~52，另一个线程打印字母 A~Z。打印顺序为 12A34B56C........5152Z。要求用线程间的通信 

​       题目难度：

​       题目考核知识点：多线程

​       答案：

```java
  public class TwoThread {
    
    public static void main(String args[]){
        MyObject1 my = new MyObject1();
        new Thread(new Runnable(){

            @Override
            public void run() {
                for(int i = 0; i < 26; i++){
                    my.printNum();
                }
            }
            
        }).start();
        new Thread(new Runnable(){

            @Override
            public void run() {
                for(int i = 0; i < 26; i++){
                    my.printA();
                }
            }
            
        }).start();
    }
}
class MyObject1{
    private static boolean flag = true ;
    public  int count = 1;
    
    public synchronized void printNum(){
        while(flag == false){
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.print((2*count-1));
        System.out.print(2*count);
        
        flag = false;
        this.notify();
    }
    public synchronized void printA(){
        while(flag == true){
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.print((char)(count+'A'-1));
        count++;
        flag = true;
        this.notify();
    }
}
```

​    题目解析：一个线程打印数字，每次打印两个数字，26 次打印完，另一个线程打印字母，也是 26 次打印完；可以创建两个方法，一个方法打印数字，一个打印字母；还有创建一个全局变量用来控制具体执行的是哪个线程；每个方法都被执行 26 次。 



- ​题目说明：  编写一个程序，启动三个线程，三个线程的 ID 分别是 A，B，C；，每个线程将自己的 ID 值在屏幕上打印 5 遍，打印顺序是 ABCABC... 

​       题目难度：

​       题目考核知识点：多线程

​       答案：

```java
  public class ThreeThread extends Thread {
    
    
    public static void main(String[] args) {
        MyObject ob = new MyObject();
        new Thread(new Runnable(){
            @Override
            public void run() {
                // TODO Auto-generated method stub
                for(int i = 0 ; i<10 ; i++)
                    ob.printA();
            }
            
        }).start();
        new Thread(new Runnable(){
            @Override
            public void run() {
                // TODO Auto-generated method stub
                for(int i = 0 ; i<10 ; i++)
                    ob.printB();
            }
            
        }).start();
        new Thread(new Runnable(){
            @Override
            public void run() {
                // TODO Auto-generated method stub
                for(int i = 0 ; i<10 ; i++)
                    ob.printC();
            }
            
        }).start();
    }

}

class MyObject  {
    
    private  int flag = 1;
    
    public synchronized void printA(){
        while(flag != 1){
            try {
                this.wait();
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
            System.out.print("A");
            flag = 2;
            this.notifyAll();
            
        
        
    }
    public synchronized void printC(){
        while(flag != 3){
            try {
                this.wait();
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
            System.out.println("C");
            flag = 1;
            this.notifyAll();
            
        
        
    }
    public synchronized void printB(){
        while(flag != 2){
            try {
                this.wait();
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
            System.out.print("B");
            flag = 3;
            this.notifyAll();     
    }
    
}
```

​    题目解析：定义一个对象，将方法都同步，每个方法都用一个线程启动，对象之间有个全局变量，线程通过全局变量的设置来控制线程执行顺序。 